import numpy as np
import pandas as pd

def NN(X,Y,Layer=[3],lr=0.1,iter=10):
    np.random.seed(3)
    A=np.array(X).T # Treating it as activation function A_0
    Y=np.array(Y).T   
    n_0=A.shape[0]
    m=A.shape[1]
    L=Layer[:]
    L.insert(0,n_0)
    L.append(Y.shape[0])
    costf=[]
    d={}
    i=1
    while i <= len(L)-1:
        d["W"+str(i)]=np.random.randn(L[i],L[i-1])*0.01
        d["b"+str(i)]=np.zeros((L[i],1))
        i+=1
    #print(d)
    for itr in range(iter):
        ### forward propogation ####
        d1={}
        d1["A0"]=A
        a=1
        while a <= len(L)-1:
            d1["Z"+str(a)]=np.dot(d["W"+str(a)],d1["A"+str(a-1)]) + d["b"+str(a)]
            #if d1["Z"+str(a+1)] > 0:
            #    d1["A"+str(a+1)]=d1["Z"+str(a+1)]
            #else:
            #    d1["A"+str(a+1)]=0
            #################################################
            d1["A"+str(a)]=np.tanh(d1["Z"+str(a)]) # tanh
            #d1["A"+str(a+1)]=np.maximum(0,d1["Z"+str(a+1)])
            if a==len(L)-1: ## predictor/last layer $ Sigmoid
                d1["A"+str(a)]=1/(1+np.exp(-d1["Z"+str(a)]))
            ###############################################33
            a+=1
            
        cost=-1/m* (np.sum(np.multiply(Y,np.log(d1["A"+str(len(L)-1)]))+np.multiply((1-Y),np.log(1-d1["A"+str(len(L)-1)]))))
        costf.append(cost)
        ##backward propogation ###
        a=len(L)-1
        d2={}
        while a > 0:
            if a==len(L)-1: ## last layer
                d1["dZ" + str(a)]  = d1["A"+str(a)]-Y
            else:
                d1["dZ" + str(a)]=np.multiply(np.dot(d["W" + str(a+1)].T,d1["dZ" + str(a+1)]),(1-np.power(d1["A"+str(a)],2)))       
            d1["dW" + str(a)]=(np.dot(d1["dZ" + str(a)],d1["A"+str(a-1)].T)/m)
                               
            d1["db" + str(a)]=(np.sum(d1["dZ" + str(a)], axis=1,keepdims=True))/m
            a-=1

        i=1
        while i <= len(L)-1:
            d["W"+str(i)]=d["W"+str(i)] - lr * d1["dW" + str(i)]
            d["b"+str(i)]=d["b"+str(i)] - lr * d1["db" + str(i)]
            i+=1
        
    print(cost)    
    predict=np.where(d1["A"+str(len(L)-1)]>0.5,1,0)
    unique, counts = np.unique(predict-Y, return_counts=True)
    similar=dict(zip(unique, counts))[0]
    accuracy=(similar/m)*100
    import matplotlib.pyplot as plt
    plt.plot(costf)
    return accuracy,d1["A"+str(len(L)-1)]
